<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo写作简单笔记</title>
    <url>/2023/03/20/Hexo%E5%86%99%E4%BD%9C%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="新建笔记"><a href="#新建笔记" class="headerlink" title="新建笔记"></a>新建笔记</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p><code>layout</code> : 可选三种布局，分别是<code>post</code>、<code>page</code>、<code>draft</code>，默认是<code>post</code><br><code>title</code> : 即文章标题</p>
<h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><p>在使用<code>draft</code>布局写作之后，需要用<code>hexo publish</code>命令将草稿发布，相当于从<code>_draft</code>文件夹移动到<code>_post</code>文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<h1 id="将文章更新至博客网站中"><a href="#将文章更新至博客网站中" class="headerlink" title="将文章更新至博客网站中"></a>将文章更新至博客网站中</h1><h2 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g </span><br></pre></td></tr></table></figure>
<p>等同于<code>hexo generate</code></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>在本地运行博客用于测试</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h2 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h2><p>也可以将上面两条命令合并为一条命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>

<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>如果运行hexo命令一直出现help信息，可能是因为没有在hexo根目录下</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg常用指令</title>
    <url>/2023/03/22/ffmpeg%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="ffmpeg参数格式"><a href="#ffmpeg参数格式" class="headerlink" title="ffmpeg参数格式"></a>ffmpeg参数格式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg \</span><br><span class="line">[全局参数] \</span><br><span class="line">[输入文件参数] \</span><br><span class="line">-i [输入文件] \</span><br><span class="line">[输出文件参数] \</span><br><span class="line">[输出文件]</span><br></pre></td></tr></table></figure>
<h1 id="剪辑视频"><a href="#剪辑视频" class="headerlink" title="剪辑视频"></a>剪辑视频</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg \</span><br><span class="line">-ss 00:00:30.0 \</span><br><span class="line">-i input.mp4 \</span><br><span class="line">-c copy \</span><br><span class="line">-t 00:01:00.0 \</span><br><span class="line">output.mp4</span><br></pre></td></tr></table></figure>
<p>-i : 输入文件<br>-ss : 起始时间<br>-t : 指定时间长度，默认单位为秒<br>-to : 指定结束时间<br>-c:v : 视频编码  </p>
<blockquote>
<p><code>-c:v copy</code>保持原本编码不变<br><code>-c:v h264_nvenc</code>可以使用nvdia硬件编码</p>
</blockquote>
<h1 id="拼接音频"><a href="#拼接音频" class="headerlink" title="拼接音频"></a>拼接音频</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg \</span><br><span class="line">-f concat \</span><br><span class="line">-safe 0 \</span><br><span class="line">-i list.txt \</span><br><span class="line">-c copy \</span><br><span class="line">output.mp3 </span><br></pre></td></tr></table></figure>
<p>通过文件列表按顺序拼接，txt文件格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file &#x27;filename1&#x27;</span><br><span class="line">file &#x27;filename2&#x27;</span><br><span class="line">file &#x27;filename3&#x27;</span><br><span class="line">file &#x27;filename4&#x27;</span><br><span class="line">file &#x27;filename5&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="视频转码"><a href="#视频转码" class="headerlink" title="视频转码"></a>视频转码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg \</span><br><span class="line">-i input.mp4 \</span><br><span class="line">-vf scale=1920:1080 \</span><br><span class="line">-c:v h264_nvenc \</span><br><span class="line">-b:v 5500k \</span><br><span class="line">-c:a aac \</span><br><span class="line">-b:a 128k \</span><br><span class="line">-output.mp4</span><br></pre></td></tr></table></figure>
<p>如果编码方式不支持硬件编码，则修改<code>-c:v</code>参数<br>-b:v : 视频码率，一般6000足够清晰<br>-c:a : 音频编码<br>-b:a : 音频码率  </p>
]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>剪辑</tag>
      </tags>
  </entry>
  <entry>
    <title>通过SSH远程端口转发，实现外网访问内网主机</title>
    <url>/2023/04/07/%E9%80%9A%E8%BF%87SSH%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E4%B8%BB%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="一、使用场景"><a href="#一、使用场景" class="headerlink" title="一、使用场景"></a>一、使用场景</h1><p>校园网可以连接到校外网络，而校外无法访问校园网内的主机。为了解决这个问题，本文介绍一个基于SSH远程端口转发的方法，通过一个有公网ip的服务器B，在服务器B和校内主机A之间建立一个隧道，从而实现校外访问</p>
<p>校内主机：A<br>服务器：B<br>校外电脑：C </p>
<h1 id="二、SSH命令"><a href="#二、SSH命令" class="headerlink" title="二、SSH命令"></a>二、SSH命令</h1><p>在校内主机上输入如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -NfR 8822:localhost:22 ubuntu@enter.B.ip.address</span><br></pre></td></tr></table></figure>
<p>其中<code>enter.B.ip.address</code>为服务器ip，这样就在服务器的8822端口和校内主机的22端口之间建立了隧道。然后就可以通过<code>ssh user@enter.B.ip.address</code>访问校内主机A了</p>
<h1 id="三、配置秘钥"><a href="#三、配置秘钥" class="headerlink" title="三、配置秘钥"></a>三、配置秘钥</h1><p>第二步之后就能正常使用了，不过需要输入密码，配置秘钥之后就可以无需密码建立隧道，并且，如果要通过systemd守护进程开机自启的话，也需要配置好秘钥才行  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>执行此命令之后，默认会在<code>~/.ssh/</code>目录下生成公钥和私钥，然后通过如下指令，将公钥复制到服务器上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id ubuntu@enter.B.ip.address</span><br></pre></td></tr></table></figure>
<p>然后就能不用密码建立隧道了</p>
<h1 id="四、设置开机自启"><a href="#四、设置开机自启" class="headerlink" title="四、设置开机自启"></a>四、设置开机自启</h1><p>创建一个<code>ssh-port-forward.service</code>文件，输入以下内容，并移动到<code>/lib/systemd/system/</code>下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=SSH port forward for to jump server&#x27;s port 8822. 8822 is already mapped to public network. As a result, we can use this command to SSH login to this server: ssh -NfR 8822:localhost:22 ubuntu@enter.B.ip.address</span><br><span class="line">After=sshd.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=jia</span><br><span class="line">Group=jia</span><br><span class="line">ExecStart=/usr/bin/ssh -NR 8822:localhost:22 ubuntu@enter.B.ip.address</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">Alias=ssh-port-forward.service</span><br></pre></td></tr></table></figure>
<p>记得把里面的ip地址修改成服务器的ip，<code>[Service]</code>当中的<code>User</code>和<code>Group</code>修改成校园网主机的用户名</p>
<h1 id="五、通过scp传输文件"><a href="#五、通过scp传输文件" class="headerlink" title="五、通过scp传输文件"></a>五、通过scp传输文件</h1><p>以传输文件<code>music.mp3</code>为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -P 8822 ./music.mp3 jia@enter.B.ip.address</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux很多常用指令都失效的原因和解决方法</title>
    <url>/2023/04/18/Linux%E5%BE%88%E5%A4%9A%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E9%83%BD%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h1><p>运行以下指令  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>
<p>或者编辑<code>/etc/enviorment</code>文件把上面的命令添加进去</p>
<h1 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h1><p>今天发现很多常用的命令都用不了了，比如<code>curl</code>,<code>wget</code>，尝试过很多次卸载重装都无效，最后发现是PATH变量不知道什么时候变了，记录一下这次经历  </p>
<p>首先linux用户登录到shell的时候，会依次读取配置文件</p>
<ul>
<li>登录式 shell 读取配置 文件过程：  <ul>
<li>&#x2F;etc&#x2F;profile –&gt; &#x2F;etc&#x2F;profile.d&#x2F;*.sh –&gt; ~&#x2F;.bash_profile–&gt; ~&#x2F;.bashrc –&gt; &#x2F;etc&#x2F;bashrc</li>
</ul>
</li>
<li>非登录式 shell 读取配置 文件过程：<ul>
<li>~&#x2F;.bashrc –&gt; &#x2F;etc&#x2F;bashrc –&gt; &#x2F;etc&#x2F;prodile.d&#x2F;*.sh<br>至于什么是登录式和非登录式，可以看这个<a href="https://einverne.github.io/post/2019/01/login-shell-vs-non-login-shell.html">文章</a><blockquote>
<p>登录式 shell 是用户使用自己的 user ID 登录交互式 shell 的第一个进程。这里又要提及另外两个概念就是交互式 shell 和非交互式 shell，幸而这两个概念比较好理解。</p>
<ul>
<li><p>交互式 shell 指的是在终端有交互的模式，用户输入命令，并在回车后立即执行的 shell，这种模式也是大部分情况下用户执行的一种方式，比如 ssh 登录</p>
</li>
<li><p>非交互式 shell 指的是 bash shell 以命令脚本的形式执行，这种模式下，shell 不会和用户有交互，而是读取脚本文件并执行，直到读取到文件 EOF 时结束<br>说完这两个区别，回到主题：</p>
</li>
<li><p>当你在已经存在的终端 session 中开启一个 shell，比如在 screen, Tmux, X terminal 等中，会得到一个交互式，非登录 shell，这时 shell 会读取对应的配置（~&#x2F;.bashrc for bash, &#x2F;etc&#x2F;zshrc and ~&#x2F;.zshrc for zsh)</p>
</li>
<li><p>当 shell 执行一个脚本，或者通过命令行将命令传送过去执行，这时就是非交互，非登录的 shell。这种 shell 无处不在，在程序调用另外一个程序时非常常见<br>有一种判断 login shell vs non-login shell 的非常快速的方法，使用命令 echo $0</p>
</li>
<li><p>-bash 中 - 表示当前是一个 login shell</p>
</li>
<li><p>bash 表示不是 login shell</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>linux的变量<code>PATH</code>为可运行的程序的目录，程序的可执行文件的所在路径需要设置在<code>PATH</code>中才能直接输入指令运行<br>输入以下命令可以查看当前<code>PATH</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>
<p>在我的CentOS7里会输出这个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/java/jdk1.8.0_202-amd64/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/apache-maven-3.9.1/bin</span><br></pre></td></tr></table></figure>
<p>用<code>curl</code>举个例子，它的路径为<code>/usr/bin/curl</code>，我们也可以看到<code>PATH</code>变量中有一个<code>/usr/bin</code><br>在这个情况下，curl的环境变量就算是配好的状态了，可以直接输入输入curl而不是其完整路径&#x2F;usr&#x2F;bin&#x2F;curl来运行这个命令</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>根据查到的一些教程，PATH变量在上面说过的几个配置文件中读取，但实际上，在读取这些配置文件之前，还会读取&#x2F;etc&#x2F;enviorment文件中设置的变量<br>今天遇到的是ethtool已经安装，但是用不了的问题，先使用了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo find / -name ethtool</span><br></pre></td></tr></table></figure>
<p>查找到eth的路径在<code>/usr/sbin/ethtool</code>,而<code>PATH</code>中没有<code>/usr/sbin</code>，因此意识到环境变量可能在某个时候被误操作给改掉了<br>打开<code>/etc/enviorment</code>的时候，发现这个文件确实是空的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>
<p>加上这个就好了</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
</search>
